{"ast":null,"code":"var _slicedToArray = require(\"C:\\\\Users\\\\admin\\\\Projects\\\\mywebapp\\\\frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\admin\\\\Projects\\\\mywebapp\\\\frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\admin\\\\Projects\\\\mywebapp\\\\frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar featureQueries = require('caniuse-lite/data/features/css-featurequeries.js');\n\nvar _require = require('caniuse-lite'),\n    feature = _require.feature;\n\nvar _require2 = require('postcss'),\n    parse = _require2.parse;\n\nvar Browsers = require('./browsers');\n\nvar brackets = require('./brackets');\n\nvar Value = require('./value');\n\nvar utils = require('./utils');\n\nvar data = feature(featureQueries);\nvar supported = [];\n\nfor (var browser in data.stats) {\n  var versions = data.stats[browser];\n\n  for (var version in versions) {\n    var support = versions[version];\n\n    if (/y/.test(support)) {\n      supported.push(browser + ' ' + version);\n    }\n  }\n}\n\nvar Supports = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function Supports(Prefixes, all) {\n    _classCallCheck(this, Supports);\n\n    this.Prefixes = Prefixes;\n    this.all = all;\n  }\n  /**\n   * Return prefixer only with @supports supported browsers\n   */\n\n\n  _createClass(Supports, [{\n    key: \"prefixer\",\n    value: function prefixer() {\n      if (this.prefixerCache) {\n        return this.prefixerCache;\n      }\n\n      var filtered = this.all.browsers.selected.filter(function (i) {\n        return supported.includes(i);\n      });\n      var browsers = new Browsers(this.all.browsers.data, filtered, this.all.options);\n      this.prefixerCache = new this.Prefixes(this.all.data, browsers, this.all.options);\n      return this.prefixerCache;\n    }\n    /**\n     * Parse string into declaration property and value\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(str) {\n      var parts = str.split(':');\n      var prop = parts[0];\n      var value = parts[1];\n      if (!value) value = '';\n      return [prop.trim(), value.trim()];\n    }\n    /**\n     * Create virtual rule to process it by prefixer\n     */\n\n  }, {\n    key: \"virtual\",\n    value: function virtual(str) {\n      var _this$parse = this.parse(str),\n          _this$parse2 = _slicedToArray(_this$parse, 2),\n          prop = _this$parse2[0],\n          value = _this$parse2[1];\n\n      var rule = parse('a{}').first;\n      rule.append({\n        prop: prop,\n        value: value,\n        raws: {\n          before: ''\n        }\n      });\n      return rule;\n    }\n    /**\n     * Return array of Declaration with all necessary prefixes\n     */\n\n  }, {\n    key: \"prefixed\",\n    value: function prefixed(str) {\n      var rule = this.virtual(str);\n\n      if (this.disabled(rule.first)) {\n        return rule.nodes;\n      }\n\n      var result = {\n        warn: function warn() {\n          return null;\n        }\n      };\n      var prefixer = this.prefixer().add[rule.first.prop];\n      prefixer && prefixer.process && prefixer.process(rule.first, result);\n\n      var _iterator = _createForOfIteratorHelper(rule.nodes),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var decl = _step.value;\n\n          var _iterator2 = _createForOfIteratorHelper(this.prefixer().values('add', rule.first.prop)),\n              _step2;\n\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var value = _step2.value;\n              value.process(decl);\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n\n          Value.save(this.all, decl);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return rule.nodes;\n    }\n    /**\n     * Return true if brackets node is \"not\" word\n     */\n\n  }, {\n    key: \"isNot\",\n    value: function isNot(node) {\n      return typeof node === 'string' && /not\\s*/i.test(node);\n    }\n    /**\n     * Return true if brackets node is \"or\" word\n     */\n\n  }, {\n    key: \"isOr\",\n    value: function isOr(node) {\n      return typeof node === 'string' && /\\s*or\\s*/i.test(node);\n    }\n    /**\n     * Return true if brackets node is (prop: value)\n     */\n\n  }, {\n    key: \"isProp\",\n    value: function isProp(node) {\n      return typeof node === 'object' && node.length === 1 && typeof node[0] === 'string';\n    }\n    /**\n     * Return true if prefixed property has no unprefixed\n     */\n\n  }, {\n    key: \"isHack\",\n    value: function isHack(all, unprefixed) {\n      var check = new RegExp(\"(\\\\(|\\\\s)\".concat(utils.escapeRegexp(unprefixed), \":\"));\n      return !check.test(all);\n    }\n    /**\n     * Return true if we need to remove node\n     */\n\n  }, {\n    key: \"toRemove\",\n    value: function toRemove(str, all) {\n      var _this$parse3 = this.parse(str),\n          _this$parse4 = _slicedToArray(_this$parse3, 2),\n          prop = _this$parse4[0],\n          value = _this$parse4[1];\n\n      var unprefixed = this.all.unprefixed(prop);\n      var cleaner = this.all.cleaner();\n\n      if (cleaner.remove[prop] && cleaner.remove[prop].remove && !this.isHack(all, unprefixed)) {\n        return true;\n      }\n\n      var _iterator3 = _createForOfIteratorHelper(cleaner.values('remove', unprefixed)),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var checker = _step3.value;\n\n          if (checker.check(value)) {\n            return true;\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      return false;\n    }\n    /**\n     * Remove all unnecessary prefixes\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(nodes, all) {\n      var i = 0;\n\n      while (i < nodes.length) {\n        if (!this.isNot(nodes[i - 1]) && this.isProp(nodes[i]) && this.isOr(nodes[i + 1])) {\n          if (this.toRemove(nodes[i][0], all)) {\n            nodes.splice(i, 2);\n            continue;\n          }\n\n          i += 2;\n          continue;\n        }\n\n        if (typeof nodes[i] === 'object') {\n          nodes[i] = this.remove(nodes[i], all);\n        }\n\n        i += 1;\n      }\n\n      return nodes;\n    }\n    /**\n     * Clean brackets with one child\n     */\n\n  }, {\n    key: \"cleanBrackets\",\n    value: function cleanBrackets(nodes) {\n      var _this = this;\n\n      return nodes.map(function (i) {\n        if (typeof i !== 'object') {\n          return i;\n        }\n\n        if (i.length === 1 && typeof i[0] === 'object') {\n          return _this.cleanBrackets(i[0]);\n        }\n\n        return _this.cleanBrackets(i);\n      });\n    }\n    /**\n     * Add \" or \" between properties and convert it to brackets format\n     */\n\n  }, {\n    key: \"convert\",\n    value: function convert(progress) {\n      var result = [''];\n\n      var _iterator4 = _createForOfIteratorHelper(progress),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var i = _step4.value;\n          result.push([\"\".concat(i.prop, \": \").concat(i.value)]);\n          result.push(' or ');\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      result[result.length - 1] = '';\n      return result;\n    }\n    /**\n     * Compress value functions into a string nodes\n     */\n\n  }, {\n    key: \"normalize\",\n    value: function normalize(nodes) {\n      var _this2 = this;\n\n      if (typeof nodes !== 'object') {\n        return nodes;\n      }\n\n      nodes = nodes.filter(function (i) {\n        return i !== '';\n      });\n\n      if (typeof nodes[0] === 'string') {\n        var firstNode = nodes[0].trim();\n\n        if (firstNode.includes(':') || firstNode === 'selector' || firstNode === 'not selector') {\n          return [brackets.stringify(nodes)];\n        }\n      }\n\n      return nodes.map(function (i) {\n        return _this2.normalize(i);\n      });\n    }\n    /**\n     * Add prefixes\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(nodes, all) {\n      var _this3 = this;\n\n      return nodes.map(function (i) {\n        if (_this3.isProp(i)) {\n          var prefixed = _this3.prefixed(i[0]);\n\n          if (prefixed.length > 1) {\n            return _this3.convert(prefixed);\n          }\n\n          return i;\n        }\n\n        if (typeof i === 'object') {\n          return _this3.add(i, all);\n        }\n\n        return i;\n      });\n    }\n    /**\n     * Add prefixed declaration\n     */\n\n  }, {\n    key: \"process\",\n    value: function process(rule) {\n      var ast = brackets.parse(rule.params);\n      ast = this.normalize(ast);\n      ast = this.remove(ast, rule.params);\n      ast = this.add(ast, rule.params);\n      ast = this.cleanBrackets(ast);\n      rule.params = brackets.stringify(ast);\n    }\n    /**\n     * Check global options\n     */\n\n  }, {\n    key: \"disabled\",\n    value: function disabled(node) {\n      if (!this.all.options.grid) {\n        if (node.prop === 'display' && node.value.includes('grid')) {\n          return true;\n        }\n\n        if (node.prop.includes('grid') || node.prop === 'justify-items') {\n          return true;\n        }\n      }\n\n      if (this.all.options.flexbox === false) {\n        if (node.prop === 'display' && node.value.includes('flex')) {\n          return true;\n        }\n\n        var other = ['order', 'justify-content', 'align-items', 'align-content'];\n\n        if (node.prop.includes('flex') || other.includes(node.prop)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n  }]);\n\n  return Supports;\n}();\n\nmodule.exports = Supports;","map":null,"metadata":{},"sourceType":"script"}