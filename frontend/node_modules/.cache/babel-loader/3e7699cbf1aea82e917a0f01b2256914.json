{"ast":null,"code":"var _slicedToArray = require(\"C:\\\\Users\\\\admin\\\\Projects\\\\mywebapp\\\\frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"C:\\\\Users\\\\admin\\\\Projects\\\\mywebapp\\\\frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:\\\\Users\\\\admin\\\\Projects\\\\mywebapp\\\\frontend\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/createClass\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar _require = require('postcss'),\n    list = _require.list;\n\nvar parser = require('postcss-value-parser');\n\nvar Browsers = require('./browsers');\n\nvar vendor = require('./vendor');\n\nvar Transition = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function Transition(prefixes) {\n    _classCallCheck(this, Transition);\n\n    this.props = ['transition', 'transition-property'];\n    this.prefixes = prefixes;\n  }\n  /**\n   * Process transition and add prefixes for all necessary properties\n   */\n\n\n  _createClass(Transition, [{\n    key: \"add\",\n    value: function add(decl, result) {\n      var _this = this;\n\n      var prefix, prop;\n      var add = this.prefixes.add[decl.prop];\n      var vendorPrefixes = this.ruleVendorPrefixes(decl);\n      var declPrefixes = vendorPrefixes || add && add.prefixes || [];\n      var params = this.parse(decl.value);\n      var names = params.map(function (i) {\n        return _this.findProp(i);\n      });\n      var added = [];\n\n      if (names.some(function (i) {\n        return i[0] === '-';\n      })) {\n        return;\n      }\n\n      var _iterator = _createForOfIteratorHelper(params),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var param = _step.value;\n          prop = this.findProp(param);\n          if (prop[0] === '-') continue;\n          var prefixer = this.prefixes.add[prop];\n          if (!prefixer || !prefixer.prefixes) continue;\n\n          var _iterator3 = _createForOfIteratorHelper(prefixer.prefixes),\n              _step3;\n\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              prefix = _step3.value;\n\n              if (vendorPrefixes && !vendorPrefixes.some(function (p) {\n                return prefix.includes(p);\n              })) {\n                continue;\n              }\n\n              var prefixed = this.prefixes.prefixed(prop, prefix);\n\n              if (prefixed !== '-ms-transform' && !names.includes(prefixed)) {\n                if (!this.disabled(prop, prefix)) {\n                  added.push(this.clone(prop, prefixed, param));\n                }\n              }\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      params = params.concat(added);\n      var value = this.stringify(params);\n      var webkitClean = this.stringify(this.cleanFromUnprefixed(params, '-webkit-'));\n\n      if (declPrefixes.includes('-webkit-')) {\n        this.cloneBefore(decl, \"-webkit-\".concat(decl.prop), webkitClean);\n      }\n\n      this.cloneBefore(decl, decl.prop, webkitClean);\n\n      if (declPrefixes.includes('-o-')) {\n        var operaClean = this.stringify(this.cleanFromUnprefixed(params, '-o-'));\n        this.cloneBefore(decl, \"-o-\".concat(decl.prop), operaClean);\n      }\n\n      var _iterator2 = _createForOfIteratorHelper(declPrefixes),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          prefix = _step2.value;\n\n          if (prefix !== '-webkit-' && prefix !== '-o-') {\n            var prefixValue = this.stringify(this.cleanOtherPrefixes(params, prefix));\n            this.cloneBefore(decl, prefix + decl.prop, prefixValue);\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      if (value !== decl.value && !this.already(decl, decl.prop, value)) {\n        this.checkForWarning(result, decl);\n        decl.cloneBefore();\n        decl.value = value;\n      }\n    }\n    /**\n     * Find property name\n     */\n\n  }, {\n    key: \"findProp\",\n    value: function findProp(param) {\n      var prop = param[0].value;\n\n      if (/^\\d/.test(prop)) {\n        var _iterator4 = _createForOfIteratorHelper(param.entries()),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var _step4$value = _slicedToArray(_step4.value, 2),\n                i = _step4$value[0],\n                token = _step4$value[1];\n\n            if (i !== 0 && token.type === 'word') {\n              return token.value;\n            }\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      }\n\n      return prop;\n    }\n    /**\n     * Does we already have this declaration\n     */\n\n  }, {\n    key: \"already\",\n    value: function already(decl, prop, value) {\n      return decl.parent.some(function (i) {\n        return i.prop === prop && i.value === value;\n      });\n    }\n    /**\n     * Add declaration if it is not exist\n     */\n\n  }, {\n    key: \"cloneBefore\",\n    value: function cloneBefore(decl, prop, value) {\n      if (!this.already(decl, prop, value)) {\n        decl.cloneBefore({\n          prop: prop,\n          value: value\n        });\n      }\n    }\n    /**\n     * Show transition-property warning\n     */\n\n  }, {\n    key: \"checkForWarning\",\n    value: function checkForWarning(result, decl) {\n      var _this2 = this;\n\n      if (decl.prop !== 'transition-property') {\n        return;\n      }\n\n      var isPrefixed = false;\n      var hasAssociatedProp = false;\n      decl.parent.each(function (i) {\n        if (i.type !== 'decl') {\n          return undefined;\n        }\n\n        if (i.prop.indexOf('transition-') !== 0) {\n          return undefined;\n        }\n\n        var values = list.comma(i.value); // check if current Rule's transition-property comma separated value list needs prefixes\n\n        if (i.prop === 'transition-property') {\n          values.forEach(function (value) {\n            var lookup = _this2.prefixes.add[value];\n\n            if (lookup && lookup.prefixes && lookup.prefixes.length > 0) {\n              isPrefixed = true;\n            }\n          });\n          return undefined;\n        } // check if another transition-* prop in current Rule has comma separated value list\n\n\n        hasAssociatedProp = hasAssociatedProp || values.length > 1;\n        return false;\n      });\n\n      if (isPrefixed && hasAssociatedProp) {\n        decl.warn(result, 'Replace transition-property to transition, ' + 'because Autoprefixer could not support ' + 'any cases of transition-property ' + 'and other transition-*');\n      }\n    }\n    /**\n     * Process transition and remove all unnecessary properties\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove(decl) {\n      var _this3 = this;\n\n      var params = this.parse(decl.value);\n      params = params.filter(function (i) {\n        var prop = _this3.prefixes.remove[_this3.findProp(i)];\n\n        return !prop || !prop.remove;\n      });\n      var value = this.stringify(params);\n\n      if (decl.value === value) {\n        return;\n      }\n\n      if (params.length === 0) {\n        decl.remove();\n        return;\n      }\n\n      var double = decl.parent.some(function (i) {\n        return i.prop === decl.prop && i.value === value;\n      });\n      var smaller = decl.parent.some(function (i) {\n        return i !== decl && i.prop === decl.prop && i.value.length > value.length;\n      });\n\n      if (double || smaller) {\n        decl.remove();\n        return;\n      }\n\n      decl.value = value;\n    }\n    /**\n     * Parse properties list to array\n     */\n\n  }, {\n    key: \"parse\",\n    value: function parse(value) {\n      var ast = parser(value);\n      var result = [];\n      var param = [];\n\n      var _iterator5 = _createForOfIteratorHelper(ast.nodes),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var node = _step5.value;\n          param.push(node);\n\n          if (node.type === 'div' && node.value === ',') {\n            result.push(param);\n            param = [];\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      result.push(param);\n      return result.filter(function (i) {\n        return i.length > 0;\n      });\n    }\n    /**\n     * Return properties string from array\n     */\n\n  }, {\n    key: \"stringify\",\n    value: function stringify(params) {\n      if (params.length === 0) {\n        return '';\n      }\n\n      var nodes = [];\n\n      var _iterator6 = _createForOfIteratorHelper(params),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var param = _step6.value;\n\n          if (param[param.length - 1].type !== 'div') {\n            param.push(this.div(params));\n          }\n\n          nodes = nodes.concat(param);\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n\n      if (nodes[0].type === 'div') {\n        nodes = nodes.slice(1);\n      }\n\n      if (nodes[nodes.length - 1].type === 'div') {\n        nodes = nodes.slice(0, +-2 + 1 || undefined);\n      }\n\n      return parser.stringify({\n        nodes: nodes\n      });\n    }\n    /**\n     * Return new param array with different name\n     */\n\n  }, {\n    key: \"clone\",\n    value: function clone(origin, name, param) {\n      var result = [];\n      var changed = false;\n\n      var _iterator7 = _createForOfIteratorHelper(param),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var i = _step7.value;\n\n          if (!changed && i.type === 'word' && i.value === origin) {\n            result.push({\n              type: 'word',\n              value: name\n            });\n            changed = true;\n          } else {\n            result.push(i);\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n\n      return result;\n    }\n    /**\n     * Find or create separator\n     */\n\n  }, {\n    key: \"div\",\n    value: function div(params) {\n      var _iterator8 = _createForOfIteratorHelper(params),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var param = _step8.value;\n\n          var _iterator9 = _createForOfIteratorHelper(param),\n              _step9;\n\n          try {\n            for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n              var node = _step9.value;\n\n              if (node.type === 'div' && node.value === ',') {\n                return node;\n              }\n            }\n          } catch (err) {\n            _iterator9.e(err);\n          } finally {\n            _iterator9.f();\n          }\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n\n      return {\n        type: 'div',\n        value: ',',\n        after: ' '\n      };\n    }\n  }, {\n    key: \"cleanOtherPrefixes\",\n    value: function cleanOtherPrefixes(params, prefix) {\n      var _this4 = this;\n\n      return params.filter(function (param) {\n        var current = vendor.prefix(_this4.findProp(param));\n        return current === '' || current === prefix;\n      });\n    }\n    /**\n     * Remove all non-webkit prefixes and unprefixed params if we have prefixed\n     */\n\n  }, {\n    key: \"cleanFromUnprefixed\",\n    value: function cleanFromUnprefixed(params, prefix) {\n      var _this5 = this;\n\n      var remove = params.map(function (i) {\n        return _this5.findProp(i);\n      }).filter(function (i) {\n        return i.slice(0, prefix.length) === prefix;\n      }).map(function (i) {\n        return _this5.prefixes.unprefixed(i);\n      });\n      var result = [];\n\n      var _iterator10 = _createForOfIteratorHelper(params),\n          _step10;\n\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var param = _step10.value;\n          var prop = this.findProp(param);\n          var p = vendor.prefix(prop);\n\n          if (!remove.includes(prop) && (p === prefix || p === '')) {\n            result.push(param);\n          }\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n\n      return result;\n    }\n    /**\n     * Check property for disabled by option\n     */\n\n  }, {\n    key: \"disabled\",\n    value: function disabled(prop, prefix) {\n      var other = ['order', 'justify-content', 'align-self', 'align-content'];\n\n      if (prop.includes('flex') || other.includes(prop)) {\n        if (this.prefixes.options.flexbox === false) {\n          return true;\n        }\n\n        if (this.prefixes.options.flexbox === 'no-2009') {\n          return prefix.includes('2009');\n        }\n      }\n\n      return undefined;\n    }\n    /**\n     * Check if transition prop is inside vendor specific rule\n     */\n\n  }, {\n    key: \"ruleVendorPrefixes\",\n    value: function ruleVendorPrefixes(decl) {\n      var parent = decl.parent;\n\n      if (parent.type !== 'rule') {\n        return false;\n      } else if (!parent.selector.includes(':-')) {\n        return false;\n      }\n\n      var selectors = Browsers.prefixes().filter(function (s) {\n        return parent.selector.includes(':' + s);\n      });\n      return selectors.length > 0 ? selectors : false;\n    }\n  }]);\n\n  return Transition;\n}();\n\nmodule.exports = Transition;","map":null,"metadata":{},"sourceType":"script"}