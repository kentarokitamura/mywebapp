{"ast":null,"code":"var AND_REGEXP = /^\\s+and\\s+(.*)/i;\nvar OR_REGEXP = /^(?:,\\s*|\\s+or\\s+)(.*)/i;\n\nfunction flatten(array) {\n  if (!Array.isArray(array)) return [array];\n  return array.reduce(function (a, b) {\n    return a.concat(flatten(b));\n  }, []);\n}\n\nfunction find(string, predicate) {\n  for (var n = 1, max = string.length; n <= max; n++) {\n    var parsed = string.substr(-n, n);\n\n    if (predicate(parsed, n, max)) {\n      return string.slice(0, -n);\n    }\n  }\n\n  return '';\n}\n\nfunction matchQuery(all, query) {\n  var node = {\n    query: query\n  };\n\n  if (query.indexOf('not ') === 0) {\n    node.not = true;\n    query = query.slice(4);\n  }\n\n  for (var name in all) {\n    var type = all[name];\n    var match = query.match(type.regexp);\n\n    if (match) {\n      node.type = name;\n\n      for (var i = 0; i < type.matches.length; i++) {\n        node[type.matches[i]] = match[i + 1];\n      }\n\n      return node;\n    }\n  }\n\n  node.type = 'unknown';\n  return node;\n}\n\nfunction matchBlock(all, string, qs) {\n  var node;\n  return find(string, function (parsed, n, max) {\n    if (AND_REGEXP.test(parsed)) {\n      node = matchQuery(all, parsed.match(AND_REGEXP)[1]);\n      node.compose = 'and';\n      qs.unshift(node);\n      return true;\n    } else if (OR_REGEXP.test(parsed)) {\n      node = matchQuery(all, parsed.match(OR_REGEXP)[1]);\n      node.compose = 'or';\n      qs.unshift(node);\n      return true;\n    } else if (n === max) {\n      node = matchQuery(all, parsed.trim());\n      node.compose = 'or';\n      qs.unshift(node);\n      return true;\n    }\n\n    return false;\n  });\n}\n\nmodule.exports = function parse(all, queries) {\n  if (!Array.isArray(queries)) queries = [queries];\n  return flatten(queries.map(function (block) {\n    var qs = [];\n\n    do {\n      block = matchBlock(all, block, qs);\n    } while (block);\n\n    return qs;\n  }));\n};","map":null,"metadata":{},"sourceType":"script"}